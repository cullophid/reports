// Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateChartNode {
  count: Int!
}

type AggregateReport {
  count: Int!
}

type AggregateSlide {
  count: Int!
}

type AggregateTextNode {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type ChartNode {
  id: ID!
  slide: Slide!
  x: Int!
  y: Int!
  width: Int!
  height: Int!
  query: String!
}

type ChartNodeConnection {
  pageInfo: PageInfo!
  edges: [ChartNodeEdge]!
  aggregate: AggregateChartNode!
}

input ChartNodeCreateInput {
  id: ID
  slide: SlideCreateOneWithoutChartNodesInput!
  x: Int!
  y: Int!
  width: Int!
  height: Int!
  query: String!
}

input ChartNodeCreateManyWithoutSlideInput {
  create: [ChartNodeCreateWithoutSlideInput!]
  connect: [ChartNodeWhereUniqueInput!]
}

input ChartNodeCreateWithoutSlideInput {
  id: ID
  x: Int!
  y: Int!
  width: Int!
  height: Int!
  query: String!
}

type ChartNodeEdge {
  node: ChartNode!
  cursor: String!
}

enum ChartNodeOrderByInput {
  id_ASC
  id_DESC
  x_ASC
  x_DESC
  y_ASC
  y_DESC
  width_ASC
  width_DESC
  height_ASC
  height_DESC
  query_ASC
  query_DESC
}

type ChartNodePreviousValues {
  id: ID!
  x: Int!
  y: Int!
  width: Int!
  height: Int!
  query: String!
}

input ChartNodeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  width: Int
  width_not: Int
  width_in: [Int!]
  width_not_in: [Int!]
  width_lt: Int
  width_lte: Int
  width_gt: Int
  width_gte: Int
  height: Int
  height_not: Int
  height_in: [Int!]
  height_not_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_gt: Int
  height_gte: Int
  query: String
  query_not: String
  query_in: [String!]
  query_not_in: [String!]
  query_lt: String
  query_lte: String
  query_gt: String
  query_gte: String
  query_contains: String
  query_not_contains: String
  query_starts_with: String
  query_not_starts_with: String
  query_ends_with: String
  query_not_ends_with: String
  AND: [ChartNodeScalarWhereInput!]
  OR: [ChartNodeScalarWhereInput!]
  NOT: [ChartNodeScalarWhereInput!]
}

type ChartNodeSubscriptionPayload {
  mutation: MutationType!
  node: ChartNode
  updatedFields: [String!]
  previousValues: ChartNodePreviousValues
}

input ChartNodeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChartNodeWhereInput
  AND: [ChartNodeSubscriptionWhereInput!]
  OR: [ChartNodeSubscriptionWhereInput!]
  NOT: [ChartNodeSubscriptionWhereInput!]
}

input ChartNodeUpdateInput {
  slide: SlideUpdateOneRequiredWithoutChartNodesInput
  x: Int
  y: Int
  width: Int
  height: Int
  query: String
}

input ChartNodeUpdateManyDataInput {
  x: Int
  y: Int
  width: Int
  height: Int
  query: String
}

input ChartNodeUpdateManyMutationInput {
  x: Int
  y: Int
  width: Int
  height: Int
  query: String
}

input ChartNodeUpdateManyWithoutSlideInput {
  create: [ChartNodeCreateWithoutSlideInput!]
  delete: [ChartNodeWhereUniqueInput!]
  connect: [ChartNodeWhereUniqueInput!]
  set: [ChartNodeWhereUniqueInput!]
  disconnect: [ChartNodeWhereUniqueInput!]
  update: [ChartNodeUpdateWithWhereUniqueWithoutSlideInput!]
  upsert: [ChartNodeUpsertWithWhereUniqueWithoutSlideInput!]
  deleteMany: [ChartNodeScalarWhereInput!]
  updateMany: [ChartNodeUpdateManyWithWhereNestedInput!]
}

input ChartNodeUpdateManyWithWhereNestedInput {
  where: ChartNodeScalarWhereInput!
  data: ChartNodeUpdateManyDataInput!
}

input ChartNodeUpdateWithoutSlideDataInput {
  x: Int
  y: Int
  width: Int
  height: Int
  query: String
}

input ChartNodeUpdateWithWhereUniqueWithoutSlideInput {
  where: ChartNodeWhereUniqueInput!
  data: ChartNodeUpdateWithoutSlideDataInput!
}

input ChartNodeUpsertWithWhereUniqueWithoutSlideInput {
  where: ChartNodeWhereUniqueInput!
  update: ChartNodeUpdateWithoutSlideDataInput!
  create: ChartNodeCreateWithoutSlideInput!
}

input ChartNodeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slide: SlideWhereInput
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  width: Int
  width_not: Int
  width_in: [Int!]
  width_not_in: [Int!]
  width_lt: Int
  width_lte: Int
  width_gt: Int
  width_gte: Int
  height: Int
  height_not: Int
  height_in: [Int!]
  height_not_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_gt: Int
  height_gte: Int
  query: String
  query_not: String
  query_in: [String!]
  query_not_in: [String!]
  query_lt: String
  query_lte: String
  query_gt: String
  query_gte: String
  query_contains: String
  query_not_contains: String
  query_starts_with: String
  query_not_starts_with: String
  query_ends_with: String
  query_not_ends_with: String
  AND: [ChartNodeWhereInput!]
  OR: [ChartNodeWhereInput!]
  NOT: [ChartNodeWhereInput!]
}

input ChartNodeWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createChartNode(data: ChartNodeCreateInput!): ChartNode!
  updateChartNode(data: ChartNodeUpdateInput!, where: ChartNodeWhereUniqueInput!): ChartNode
  updateManyChartNodes(data: ChartNodeUpdateManyMutationInput!, where: ChartNodeWhereInput): BatchPayload!
  upsertChartNode(where: ChartNodeWhereUniqueInput!, create: ChartNodeCreateInput!, update: ChartNodeUpdateInput!): ChartNode!
  deleteChartNode(where: ChartNodeWhereUniqueInput!): ChartNode
  deleteManyChartNodes(where: ChartNodeWhereInput): BatchPayload!
  createReport(data: ReportCreateInput!): Report!
  updateReport(data: ReportUpdateInput!, where: ReportWhereUniqueInput!): Report
  updateManyReports(data: ReportUpdateManyMutationInput!, where: ReportWhereInput): BatchPayload!
  upsertReport(where: ReportWhereUniqueInput!, create: ReportCreateInput!, update: ReportUpdateInput!): Report!
  deleteReport(where: ReportWhereUniqueInput!): Report
  deleteManyReports(where: ReportWhereInput): BatchPayload!
  createSlide(data: SlideCreateInput!): Slide!
  updateSlide(data: SlideUpdateInput!, where: SlideWhereUniqueInput!): Slide
  upsertSlide(where: SlideWhereUniqueInput!, create: SlideCreateInput!, update: SlideUpdateInput!): Slide!
  deleteSlide(where: SlideWhereUniqueInput!): Slide
  deleteManySlides(where: SlideWhereInput): BatchPayload!
  createTextNode(data: TextNodeCreateInput!): TextNode!
  updateTextNode(data: TextNodeUpdateInput!, where: TextNodeWhereUniqueInput!): TextNode
  updateManyTextNodes(data: TextNodeUpdateManyMutationInput!, where: TextNodeWhereInput): BatchPayload!
  upsertTextNode(where: TextNodeWhereUniqueInput!, create: TextNodeCreateInput!, update: TextNodeUpdateInput!): TextNode!
  deleteTextNode(where: TextNodeWhereUniqueInput!): TextNode
  deleteManyTextNodes(where: TextNodeWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  chartNode(where: ChartNodeWhereUniqueInput!): ChartNode
  chartNodes(where: ChartNodeWhereInput, orderBy: ChartNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChartNode]!
  chartNodesConnection(where: ChartNodeWhereInput, orderBy: ChartNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChartNodeConnection!
  report(where: ReportWhereUniqueInput!): Report
  reports(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Report]!
  reportsConnection(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReportConnection!
  slide(where: SlideWhereUniqueInput!): Slide
  slides(where: SlideWhereInput, orderBy: SlideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Slide]!
  slidesConnection(where: SlideWhereInput, orderBy: SlideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SlideConnection!
  textNode(where: TextNodeWhereUniqueInput!): TextNode
  textNodes(where: TextNodeWhereInput, orderBy: TextNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TextNode]!
  textNodesConnection(where: TextNodeWhereInput, orderBy: TextNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TextNodeConnection!
  node(id: ID!): Node
}

type Report {
  id: ID!
  title: String!
  owner: ID!
  width: Int!
  height: Int!
  slides(where: SlideWhereInput, orderBy: SlideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Slide!]
}

type ReportConnection {
  pageInfo: PageInfo!
  edges: [ReportEdge]!
  aggregate: AggregateReport!
}

input ReportCreateInput {
  id: ID
  title: String!
  owner: ID!
  width: Int!
  height: Int!
  slides: SlideCreateManyWithoutReportInput
}

input ReportCreateOneWithoutSlidesInput {
  create: ReportCreateWithoutSlidesInput
  connect: ReportWhereUniqueInput
}

input ReportCreateWithoutSlidesInput {
  id: ID
  title: String!
  owner: ID!
  width: Int!
  height: Int!
}

type ReportEdge {
  node: Report!
  cursor: String!
}

enum ReportOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  owner_ASC
  owner_DESC
  width_ASC
  width_DESC
  height_ASC
  height_DESC
}

type ReportPreviousValues {
  id: ID!
  title: String!
  owner: ID!
  width: Int!
  height: Int!
}

type ReportSubscriptionPayload {
  mutation: MutationType!
  node: Report
  updatedFields: [String!]
  previousValues: ReportPreviousValues
}

input ReportSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReportWhereInput
  AND: [ReportSubscriptionWhereInput!]
  OR: [ReportSubscriptionWhereInput!]
  NOT: [ReportSubscriptionWhereInput!]
}

input ReportUpdateInput {
  title: String
  owner: ID
  width: Int
  height: Int
  slides: SlideUpdateManyWithoutReportInput
}

input ReportUpdateManyMutationInput {
  title: String
  owner: ID
  width: Int
  height: Int
}

input ReportUpdateOneRequiredWithoutSlidesInput {
  create: ReportCreateWithoutSlidesInput
  update: ReportUpdateWithoutSlidesDataInput
  upsert: ReportUpsertWithoutSlidesInput
  connect: ReportWhereUniqueInput
}

input ReportUpdateWithoutSlidesDataInput {
  title: String
  owner: ID
  width: Int
  height: Int
}

input ReportUpsertWithoutSlidesInput {
  update: ReportUpdateWithoutSlidesDataInput!
  create: ReportCreateWithoutSlidesInput!
}

input ReportWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  owner: ID
  owner_not: ID
  owner_in: [ID!]
  owner_not_in: [ID!]
  owner_lt: ID
  owner_lte: ID
  owner_gt: ID
  owner_gte: ID
  owner_contains: ID
  owner_not_contains: ID
  owner_starts_with: ID
  owner_not_starts_with: ID
  owner_ends_with: ID
  owner_not_ends_with: ID
  width: Int
  width_not: Int
  width_in: [Int!]
  width_not_in: [Int!]
  width_lt: Int
  width_lte: Int
  width_gt: Int
  width_gte: Int
  height: Int
  height_not: Int
  height_in: [Int!]
  height_not_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_gt: Int
  height_gte: Int
  slides_every: SlideWhereInput
  slides_some: SlideWhereInput
  slides_none: SlideWhereInput
  AND: [ReportWhereInput!]
  OR: [ReportWhereInput!]
  NOT: [ReportWhereInput!]
}

input ReportWhereUniqueInput {
  id: ID
}

type Slide {
  report: Report!
  id: ID!
  textNodes(where: TextNodeWhereInput, orderBy: TextNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TextNode!]
  chartNodes(where: ChartNodeWhereInput, orderBy: ChartNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChartNode!]
}

type SlideConnection {
  pageInfo: PageInfo!
  edges: [SlideEdge]!
  aggregate: AggregateSlide!
}

input SlideCreateInput {
  report: ReportCreateOneWithoutSlidesInput!
  id: ID
  textNodes: TextNodeCreateManyWithoutSlideInput
  chartNodes: ChartNodeCreateManyWithoutSlideInput
}

input SlideCreateManyWithoutReportInput {
  create: [SlideCreateWithoutReportInput!]
  connect: [SlideWhereUniqueInput!]
}

input SlideCreateOneWithoutChartNodesInput {
  create: SlideCreateWithoutChartNodesInput
  connect: SlideWhereUniqueInput
}

input SlideCreateOneWithoutTextNodesInput {
  create: SlideCreateWithoutTextNodesInput
  connect: SlideWhereUniqueInput
}

input SlideCreateWithoutChartNodesInput {
  report: ReportCreateOneWithoutSlidesInput!
  id: ID
  textNodes: TextNodeCreateManyWithoutSlideInput
}

input SlideCreateWithoutReportInput {
  id: ID
  textNodes: TextNodeCreateManyWithoutSlideInput
  chartNodes: ChartNodeCreateManyWithoutSlideInput
}

input SlideCreateWithoutTextNodesInput {
  report: ReportCreateOneWithoutSlidesInput!
  id: ID
  chartNodes: ChartNodeCreateManyWithoutSlideInput
}

type SlideEdge {
  node: Slide!
  cursor: String!
}

enum SlideOrderByInput {
  id_ASC
  id_DESC
}

type SlidePreviousValues {
  id: ID!
}

input SlideScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [SlideScalarWhereInput!]
  OR: [SlideScalarWhereInput!]
  NOT: [SlideScalarWhereInput!]
}

type SlideSubscriptionPayload {
  mutation: MutationType!
  node: Slide
  updatedFields: [String!]
  previousValues: SlidePreviousValues
}

input SlideSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SlideWhereInput
  AND: [SlideSubscriptionWhereInput!]
  OR: [SlideSubscriptionWhereInput!]
  NOT: [SlideSubscriptionWhereInput!]
}

input SlideUpdateInput {
  report: ReportUpdateOneRequiredWithoutSlidesInput
  textNodes: TextNodeUpdateManyWithoutSlideInput
  chartNodes: ChartNodeUpdateManyWithoutSlideInput
}

input SlideUpdateManyWithoutReportInput {
  create: [SlideCreateWithoutReportInput!]
  delete: [SlideWhereUniqueInput!]
  connect: [SlideWhereUniqueInput!]
  set: [SlideWhereUniqueInput!]
  disconnect: [SlideWhereUniqueInput!]
  update: [SlideUpdateWithWhereUniqueWithoutReportInput!]
  upsert: [SlideUpsertWithWhereUniqueWithoutReportInput!]
  deleteMany: [SlideScalarWhereInput!]
}

input SlideUpdateOneRequiredWithoutChartNodesInput {
  create: SlideCreateWithoutChartNodesInput
  update: SlideUpdateWithoutChartNodesDataInput
  upsert: SlideUpsertWithoutChartNodesInput
  connect: SlideWhereUniqueInput
}

input SlideUpdateOneRequiredWithoutTextNodesInput {
  create: SlideCreateWithoutTextNodesInput
  update: SlideUpdateWithoutTextNodesDataInput
  upsert: SlideUpsertWithoutTextNodesInput
  connect: SlideWhereUniqueInput
}

input SlideUpdateWithoutChartNodesDataInput {
  report: ReportUpdateOneRequiredWithoutSlidesInput
  textNodes: TextNodeUpdateManyWithoutSlideInput
}

input SlideUpdateWithoutReportDataInput {
  textNodes: TextNodeUpdateManyWithoutSlideInput
  chartNodes: ChartNodeUpdateManyWithoutSlideInput
}

input SlideUpdateWithoutTextNodesDataInput {
  report: ReportUpdateOneRequiredWithoutSlidesInput
  chartNodes: ChartNodeUpdateManyWithoutSlideInput
}

input SlideUpdateWithWhereUniqueWithoutReportInput {
  where: SlideWhereUniqueInput!
  data: SlideUpdateWithoutReportDataInput!
}

input SlideUpsertWithoutChartNodesInput {
  update: SlideUpdateWithoutChartNodesDataInput!
  create: SlideCreateWithoutChartNodesInput!
}

input SlideUpsertWithoutTextNodesInput {
  update: SlideUpdateWithoutTextNodesDataInput!
  create: SlideCreateWithoutTextNodesInput!
}

input SlideUpsertWithWhereUniqueWithoutReportInput {
  where: SlideWhereUniqueInput!
  update: SlideUpdateWithoutReportDataInput!
  create: SlideCreateWithoutReportInput!
}

input SlideWhereInput {
  report: ReportWhereInput
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  textNodes_every: TextNodeWhereInput
  textNodes_some: TextNodeWhereInput
  textNodes_none: TextNodeWhereInput
  chartNodes_every: ChartNodeWhereInput
  chartNodes_some: ChartNodeWhereInput
  chartNodes_none: ChartNodeWhereInput
  AND: [SlideWhereInput!]
  OR: [SlideWhereInput!]
  NOT: [SlideWhereInput!]
}

input SlideWhereUniqueInput {
  id: ID
}

type Subscription {
  chartNode(where: ChartNodeSubscriptionWhereInput): ChartNodeSubscriptionPayload
  report(where: ReportSubscriptionWhereInput): ReportSubscriptionPayload
  slide(where: SlideSubscriptionWhereInput): SlideSubscriptionPayload
  textNode(where: TextNodeSubscriptionWhereInput): TextNodeSubscriptionPayload
}

enum TextAlign {
  Left
  Right
  Center
}

type TextNode {
  id: ID!
  slide: Slide!
  fontSize: Int!
  color: String!
  textAlign: TextAlign!
  x: Int!
  y: Int!
  width: Int!
  height: Int!
  value: String!
}

type TextNodeConnection {
  pageInfo: PageInfo!
  edges: [TextNodeEdge]!
  aggregate: AggregateTextNode!
}

input TextNodeCreateInput {
  id: ID
  slide: SlideCreateOneWithoutTextNodesInput!
  fontSize: Int!
  color: String!
  textAlign: TextAlign!
  x: Int!
  y: Int!
  width: Int!
  height: Int!
  value: String!
}

input TextNodeCreateManyWithoutSlideInput {
  create: [TextNodeCreateWithoutSlideInput!]
  connect: [TextNodeWhereUniqueInput!]
}

input TextNodeCreateWithoutSlideInput {
  id: ID
  fontSize: Int!
  color: String!
  textAlign: TextAlign!
  x: Int!
  y: Int!
  width: Int!
  height: Int!
  value: String!
}

type TextNodeEdge {
  node: TextNode!
  cursor: String!
}

enum TextNodeOrderByInput {
  id_ASC
  id_DESC
  fontSize_ASC
  fontSize_DESC
  color_ASC
  color_DESC
  textAlign_ASC
  textAlign_DESC
  x_ASC
  x_DESC
  y_ASC
  y_DESC
  width_ASC
  width_DESC
  height_ASC
  height_DESC
  value_ASC
  value_DESC
}

type TextNodePreviousValues {
  id: ID!
  fontSize: Int!
  color: String!
  textAlign: TextAlign!
  x: Int!
  y: Int!
  width: Int!
  height: Int!
  value: String!
}

input TextNodeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fontSize: Int
  fontSize_not: Int
  fontSize_in: [Int!]
  fontSize_not_in: [Int!]
  fontSize_lt: Int
  fontSize_lte: Int
  fontSize_gt: Int
  fontSize_gte: Int
  color: String
  color_not: String
  color_in: [String!]
  color_not_in: [String!]
  color_lt: String
  color_lte: String
  color_gt: String
  color_gte: String
  color_contains: String
  color_not_contains: String
  color_starts_with: String
  color_not_starts_with: String
  color_ends_with: String
  color_not_ends_with: String
  textAlign: TextAlign
  textAlign_not: TextAlign
  textAlign_in: [TextAlign!]
  textAlign_not_in: [TextAlign!]
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  width: Int
  width_not: Int
  width_in: [Int!]
  width_not_in: [Int!]
  width_lt: Int
  width_lte: Int
  width_gt: Int
  width_gte: Int
  height: Int
  height_not: Int
  height_in: [Int!]
  height_not_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_gt: Int
  height_gte: Int
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  AND: [TextNodeScalarWhereInput!]
  OR: [TextNodeScalarWhereInput!]
  NOT: [TextNodeScalarWhereInput!]
}

type TextNodeSubscriptionPayload {
  mutation: MutationType!
  node: TextNode
  updatedFields: [String!]
  previousValues: TextNodePreviousValues
}

input TextNodeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TextNodeWhereInput
  AND: [TextNodeSubscriptionWhereInput!]
  OR: [TextNodeSubscriptionWhereInput!]
  NOT: [TextNodeSubscriptionWhereInput!]
}

input TextNodeUpdateInput {
  slide: SlideUpdateOneRequiredWithoutTextNodesInput
  fontSize: Int
  color: String
  textAlign: TextAlign
  x: Int
  y: Int
  width: Int
  height: Int
  value: String
}

input TextNodeUpdateManyDataInput {
  fontSize: Int
  color: String
  textAlign: TextAlign
  x: Int
  y: Int
  width: Int
  height: Int
  value: String
}

input TextNodeUpdateManyMutationInput {
  fontSize: Int
  color: String
  textAlign: TextAlign
  x: Int
  y: Int
  width: Int
  height: Int
  value: String
}

input TextNodeUpdateManyWithoutSlideInput {
  create: [TextNodeCreateWithoutSlideInput!]
  delete: [TextNodeWhereUniqueInput!]
  connect: [TextNodeWhereUniqueInput!]
  set: [TextNodeWhereUniqueInput!]
  disconnect: [TextNodeWhereUniqueInput!]
  update: [TextNodeUpdateWithWhereUniqueWithoutSlideInput!]
  upsert: [TextNodeUpsertWithWhereUniqueWithoutSlideInput!]
  deleteMany: [TextNodeScalarWhereInput!]
  updateMany: [TextNodeUpdateManyWithWhereNestedInput!]
}

input TextNodeUpdateManyWithWhereNestedInput {
  where: TextNodeScalarWhereInput!
  data: TextNodeUpdateManyDataInput!
}

input TextNodeUpdateWithoutSlideDataInput {
  fontSize: Int
  color: String
  textAlign: TextAlign
  x: Int
  y: Int
  width: Int
  height: Int
  value: String
}

input TextNodeUpdateWithWhereUniqueWithoutSlideInput {
  where: TextNodeWhereUniqueInput!
  data: TextNodeUpdateWithoutSlideDataInput!
}

input TextNodeUpsertWithWhereUniqueWithoutSlideInput {
  where: TextNodeWhereUniqueInput!
  update: TextNodeUpdateWithoutSlideDataInput!
  create: TextNodeCreateWithoutSlideInput!
}

input TextNodeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slide: SlideWhereInput
  fontSize: Int
  fontSize_not: Int
  fontSize_in: [Int!]
  fontSize_not_in: [Int!]
  fontSize_lt: Int
  fontSize_lte: Int
  fontSize_gt: Int
  fontSize_gte: Int
  color: String
  color_not: String
  color_in: [String!]
  color_not_in: [String!]
  color_lt: String
  color_lte: String
  color_gt: String
  color_gte: String
  color_contains: String
  color_not_contains: String
  color_starts_with: String
  color_not_starts_with: String
  color_ends_with: String
  color_not_ends_with: String
  textAlign: TextAlign
  textAlign_not: TextAlign
  textAlign_in: [TextAlign!]
  textAlign_not_in: [TextAlign!]
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  width: Int
  width_not: Int
  width_in: [Int!]
  width_not_in: [Int!]
  width_lt: Int
  width_lte: Int
  width_gt: Int
  width_gte: Int
  height: Int
  height_not: Int
  height_in: [Int!]
  height_not_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_gt: Int
  height_gte: Int
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  AND: [TextNodeWhereInput!]
  OR: [TextNodeWhereInput!]
  NOT: [TextNodeWhereInput!]
}

input TextNodeWhereUniqueInput {
  id: ID
}
`